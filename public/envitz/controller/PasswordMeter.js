/*
 * File: envitz/controller/PasswordMeter.js
 *
 * This file was generated by Sencha Architect version 3.0.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.2.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('envitz.controller.PasswordMeter', {
	extend: 'Ext.app.Controller',

	requires: [
		'Ext.Crypto',
		'Ext.Crypto.Base64'
	],

	showChart: false,
	models: [
		'passCypto'
	],
	stores: [
		'passCryptos'
	],
	views: [
		'PasswordMeter'
	],

	refs: [
		{
			autoCreate: true,
			ref: 'psMeter',
			selector: '#Passwords',
			xtype: 'Ext.container.Container'
		},
		{
			ref: 'passwordChart',
			selector: '#passwordChart'
		}
	],

	onPasswordChange: function(field, newValue, oldValue, eOpts) {
		/*
			Check the complexity of the first password string.
		*/

		this.passwordRequirementsCheck(newValue);
	},

	onPassword0Change: function(field, newValue, oldValue, eOpts) {
		/*
			This function only verifies the 2nd password matches the first string and is not concerned with complexity
		*/

		var pass = this.getPsMeter().down("[itemId=joinPassword]"),
			passOK = this.getPsMeter().down("[itemId=joinPassCheckResult]"),
			bgColor = "#FFFFFF";

		passOK.el.dom.innerHTML = "Waiting to check password";
		passOK.el.setStyle( {borderColor: "#B5B8C8", color: "", fontWeight: "", opacity: 0.2} );

		if (pass.getValue().length <= newValue.length && newValue.length > 0) {
			if (newValue !== pass.getValue()){
				bgColor = "#FF0000";
			} else {
				bgColor = "#00FF00";
				//user's typed pass matches, now check if pass is not accepted:
				this.isBannedPassword(newValue);
			}
		}

		//field.el.dom.style.backgroundColor = bgColor; //changes label bg...
		//default background: url("images/form/text-bg.gif") repeat-x scroll 0 0 #FFFFFF
		field.setFieldStyle( {backgroundColor: bgColor, background: bgColor} );
		pass.setFieldStyle( {backgroundColor: bgColor, background: bgColor} );

	},

	init: function(application) {
				var me=this;

				if(Ext.isGecko) console.log(" passwordMeter.ONinit()");

				if (me.showChart) {
					//set chart visibility & function...
					if (Ext.isGecko) console.log(" passwordMeter.showChart(): " + me.showChart);
					me.getPasswordChart().setVisible(me.showChart);
				}

		this.control({
			"#joinPassword": {
				change: this.onPasswordChange
			},
			"#joinPassword0": {
				change: this.onPassword0Change
			}
		});
	},

	isBannedPassword: function(password) {
		/*
		 * Makes API call to verify that user's password is not in the Banned password list
		 *
		 *
		 */

		var passOK = this.getPsMeter().down("[itemId=joinPassCheckResult]");

		password = Ext.Crypto.Base64.encode(password); // simple hash to obfuscate the password...


		Ext.Ajax.request({
			url: "/API/checkUserPass/" + Ext.Number.randomInt(0, 999999)+ "/" + password,
			success: function (ajaxObject) {

				var reply=Ext.JSON.decode(ajaxObject.responseText);
				//console.log(reply);

				if (reply.PWstatus === 1) { //update joinPassCheckResult object
					//pass is okay to use...
					//TODO: this innerHMTL text should come from API in order to support other langs...
					passOK.el.dom.innerHTML = "Nice password!";
					passOK.el.setStyle( {
						borderColor: "#00FF00",
						color: "green",
						fontWeight: "bold",
						opacity: 1.0
					} );
				} else {
					passOK.el.dom.innerHTML = "Too easy to crack...";
					passOK.el.setStyle( {
						borderColor: "#FF0000",
						color: "red",
						fontWeight: "bold",
						opacity: 1.0
					} );
				}
			},
			failure: function(o){
				//"Database error or connection failure. \n Unable to verify password.
				Alert('DataBase - Error', o.error);
				console.log(o);
			}
		});

	},

	cmpClearDisable: function(objectId, text) {
		var formComponent = this.getPsMeter().down(objectId),
			flag = false;

		try {
			if (Ext.isEmpty(text)) {
				flag = true;
				formComponent.setValue("");
			}//end if text is blank

			formComponent.setDisabled(flag);
		} catch (e) {}
	},

	passwordRequirementsCheck: function(sPassword) {
		/*
			This function is inspired by: http://www.passwordmeter.com/
			Written by Rich@RichieBartlett.com
		*/

		var scoreBar = this.getPsMeter().down("[itemId=joinPassBar]"), //gradient PNG image: 1000px x 32px
			scoreBarPos = 0,
			scoreText = this.getPsMeter().down("[itemId=joinPassScore]"),
			passMeter = this.getPsMeter().down("[itemId=joinPassMeter]"),
			passChartStore,
		// image icon references:
			passReqMax = this.getPsMeter().down("[itemId=passReqMax]"),
			passReqMin = this.getPsMeter().down("[itemId=passReqMin]"),
			passReqUpper = this.getPsMeter().down("[itemId=passReqUpper]"),
			passReqLower = this.getPsMeter().down("[itemId=passReqLower]"),
			passReqNum = this.getPsMeter().down("[itemId=passReqNum]"),
			passReqSym = this.getPsMeter().down("[itemId=passReqSym]"),
		//Icons to indicate requirement status:
		// passAccept = "/images/accept.png"; //change to base64 image data
			passAccept = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAKfSURBVDjLpZPrS1NhHMf9O3bOdmwDCWREIYKEUHsVJBI7mg3FvCxL09290jZj2EyLMnJexkgpLbPUanNOberU5taUMnHZUULMvelCtWF0sW/n7MVMEiN64AsPD8/n83uucQDi/id/DBT4Dolypw/qsz0pTMbj/WHpiDgsdSUyUmeiPt2+V7SrIM+bSss8ySGdR4abQQv6lrui6VxsRonrGCS9VEjSQ9E7CtiqdOZ4UuTqnBHO1X7YXl6Daa4yGq7vWO1D40wVDtj4kWQbn94myPGkCDPdSesczE2sCZShwl8CzcwZ6NiUs6n2nYX99T1cnKqA2EKui6+TwphA5k4yqMayopU5mANV3lNQTBdCMVUA9VQh3GuDMHiVcLCS3J4jSLhCGmKCjBEx0xlshjXYhApfMZRP5CyYD+UkG08+xt+4wLVQZA1tzxthm2tEfD3JxARH7QkbD1ZuozaggdZbxK5kAIsf5qGaKMTY2lAU/rH5HW3PLsEwUYy+YCcERmIjJpDcpzb6l7th9KtQ69fi09ePUej9l7cx2DJbD7UrG3r3afQHOyCo+V3QQzE35pvQvnAZukk5zL5qRL59jsKbPzdheXoBZc4saFhBS6AO7V4zqCpiawuptwQG+UAa7Ct3UT0hh9p9EnXT5Vh6t4C22QaUDh6HwnECOmcO7K+6kW49DKqS2DrEZCtfuI+9GrNHg4fMHVSO5kE7nAPVkAxKBxcOzsajpS4Yh4ohUPPWKTUh3PaQEptIOr6BiJjcZXCwktaAGfrRIpwblqOV3YKdhfXOIvBLeREWpnd8ynsaSJoyESFphwTtfjN6X1jRO2+FxWtCWksqBApeiFIR9K6fiTpPiigDoadqCEag5YUFKl6Yrciw0VOlhOivv/Ff8wtn0KzlebrUYwAAAABJRU5ErkJggg==",
		// passDecline = "/images/cancel.png";
			passDecline = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAHdSURBVDjLpZNraxpBFIb3a0ggISmmNISWXmOboKihxpgUNGWNSpvaS6RpKL3Ry//Mh1wgf6PElaCyzq67O09nVjdVlJbSDy8Lw77PmfecMwZg/I/GDw3DCo8HCkZl/RlgGA0e3Yfv7+DbAfLrW+SXOvLTG+SHV/gPbuMZRnsyIDL/OASziMxkkKkUQTJJsLaGn8/iHz6nd+8mQv87Ahg2H9Th/BxZqxEkEgSrq/iVCvLsDK9awtvfxb2zjD2ARID+lVVlbabTgWYTv1rFL5fBUtHbbeTJCb3EQ3ovCnRC6xAgzJtOE+ztheYIEkqbFaS3vY2zuIj77AmtYYDusPy8/zuvunJkDKXM7tYWTiyGWFjAqeQnAD6+7ueNx/FLpRGAru7mcoj5ebqzszil7DggeF/DX1nBN82rzPqrzbRayIsLhJqMPT2N83Sdy2GApwFqRN7jFPL0tF+10cDd3MTZ2AjNUkGCoyO6y9cRxfQowFUbpufr1ct4ZoHg+Dg067zduTmEbq4yi/UkYidDe+kaTcP4ObJIajksPd/eyx3c+N2rvPbMDPbUFPZSLKzcGjKPrbJaDsu+dQO3msfZzeGY2TCvKGYQhdSYeeJjUt21dIcjXQ7U7Kv599f4j/oF55W4g/2e3b8AAAAASUVORK5CYII=",
			passBlank = Ext.BLANK_IMAGE_URL,
		//Crypto test vars:
			nMinPwdLen = 8,
			nMaxPwdLen = 64,
			nScore=0, // 0 - 100
			nLength=0, nAlphaUC=0, nAlphaLC=0, nNumber=0, nSymbol=0, nMidChar=0, nRequirements=0, nAlphasOnly=0, nNumbersOnly=0,
			nUnqChar=0, nRepChar=0, nRepInc=0, nConsecAlphaUC=0, nConsecAlphaLC=0, nConsecNumber=0, nConsecSymbol=0, nConsecCharType=0,
			nSeqAlpha=0, nSeqNumber=0, nSeqSymbol=0, nSeqChar=0, nReqChar=0, nMultConsecCharType=0,
		//rules and weights:
			nMultRepChar=1, nMultConsecSymbol=1,
			nMultMidChar=2, nMultRequirements=2, nMultConsecAlphaUC=2, nMultConsecAlphaLC=2, nMultConsecNumber=2,
			nReqCharType=3, nMultAlphaUC=3, nMultAlphaLC=3, nMultSeqAlpha=3, nMultSeqNumber=3, nMultSeqSymbol=3,
			nMultLength=4, nMultNumber=4,
			nMultSymbol=6,
		//string processes:
			nTmpAlphaUC="", nTmpAlphaLC="", nTmpNumber="", nTmpSymbol="",
			sAlphas = "abcdefghijklmnopqrstuvwxyz",
			sNumerics = "01234567890",
			sSymbols = "!@#$%^&*().",
			bCharExists = false, b,
			s = 0, sFwd = "", sRev = "",
			arrChars, arrCharsIds, arrCharsLen,
			c, oBonus, minVal;





		if (this.showChart) {
			passChartStore = Ext.StoreMgr.lookup("passCryptos");
		}




		if (sPassword.length === 0) {
			passMeter.el.dom.style.opacity = 0.25;
			scoreBar.el.dom.style.backgroundPosition = "0 0";
			/*  Update the requirement icons */
			passReqMax.el.dom.src = passBlank;
			passReqMin.el.dom.src = passBlank;
			passReqUpper.el.dom.src = passBlank;
			passReqLower.el.dom.src = passBlank;
			passReqNum.el.dom.src = passBlank;
			passReqSym.el.dom.src = passBlank;

		} else {
			passMeter.el.dom.style.opacity = 1;


			// calculate the password metrics:
			nScore = parseInt(sPassword.length * nMultLength);
			nLength = sPassword.length;
			var arrPwd = sPassword.replace(/\s+/g, "").split(/\s*/);
			var arrPwdLen = arrPwd.length;

			/* Loop through password to check for Symbol, Numeric, Lowercase and Uppercase pattern matches */
			var a=0;
			for (a=0; a < arrPwdLen; a++) {
				if (arrPwd[a].match(/[A-Z]/g)) {
					if (nTmpAlphaUC !== "") {
						if ((nTmpAlphaUC + 1) == a) {
							nConsecAlphaUC++;
							nConsecCharType++;
						}
					}
					nTmpAlphaUC = a;
					nAlphaUC++;
				} else if (arrPwd[a].match(/[a-z]/g)) {
					if (nTmpAlphaLC !== "") {
						if ((nTmpAlphaLC + 1) == a) {
							nConsecAlphaLC++;
							nConsecCharType++;
						}
					}
					nTmpAlphaLC = a;
					nAlphaLC++;
				} else if (arrPwd[a].match(/[0-9]/g)) {
					if (a > 0 && a < (arrPwdLen - 1)) {
						nMidChar++;
					}
					if (nTmpNumber !== "") {
						if ((nTmpNumber + 1) == a) {
							nConsecNumber++;
							nConsecCharType++;
						}
					}
					nTmpNumber = a;
					nNumber++;
				} else if (arrPwd[a].match(/[^a-zA-Z0-9_]/g)) {
					if (a > 0 && a < (arrPwdLen - 1)) {
						nMidChar++;
					}
					if (nTmpSymbol !== "") {
						if ((nTmpSymbol + 1) == a) {
							nConsecSymbol++;
							nConsecCharType++;
						}
					}
					nTmpSymbol = a;
					nSymbol++;
				}

				/* Internal loop through password to check for repeat characters */
				for(b=0; b < arrPwdLen; b++) {
					if (arrPwd[a] == arrPwd[b] && a != b) { /* repeat character exists */
						bCharExists = true;
						/*
						Calculate increment deduction based on proximity to identical characters
						Deduction is incremented each time a new match is discovered
						Deduction amount is based on total password length divided by the
						difference of distance between currently selected match
						*/
						nRepInc += Math.abs(arrPwdLen/(b-a));
					}
				}
				if (bCharExists) {
					nRepChar++;
					nUnqChar = arrPwdLen-nRepChar;
					nRepInc = (nUnqChar) ? Math.ceil(nRepInc/nUnqChar) : Math.ceil(nRepInc);
				}
			}

			/* Check for sequential alpha string patterns (forward and reverse) */
			for( s=0; s < 23; s++) {
				sFwd = sAlphas.substring(s,parseInt(s + 3));
				sRev = sFwd.strReverse();
				if (sPassword.toLowerCase().indexOf(sFwd) != -1 || sPassword.toLowerCase().indexOf(sRev) != -1) {
					nSeqAlpha++;
					nSeqChar++;
				}
			}

			/* Check for sequential numeric string patterns (forward and reverse) */
			for (s=0; s < 8; s++) {
				sFwd = sNumerics.substring(s,parseInt(s + 3));
				sRev = sFwd.strReverse();
				if (sPassword.toLowerCase().indexOf(sFwd) != -1 || sPassword.toLowerCase().indexOf(sRev) != -1) {
					nSeqNumber++;
					nSeqChar++;
				}
			}

			/* Check for sequential symbol string patterns (forward and reverse) */
			for (s=0; s < 8; s++) {
				sFwd = sSymbols.substring(s,parseInt(s + 3));
				sRev = sFwd.strReverse();
				if (sPassword.toLowerCase().indexOf(sFwd) != -1 || sPassword.toLowerCase().indexOf(sRev) != -1) {
					nSeqSymbol++;
					nSeqChar++;
				}
			}

			/* Modify overall score value based on usage vs requirements */

			/* General point assignment */
			if (nAlphaUC > 0 && nAlphaUC < nLength) {
				nScore = parseInt(nScore + ((nLength - nAlphaUC) * 2));
			}
			if (nAlphaLC > 0 && nAlphaLC < nLength) {
				nScore = parseInt(nScore + ((nLength - nAlphaLC) * 2));
			}
			if (nNumber > 0 && nNumber < nLength) {
				nScore = parseInt(nScore + (nNumber * nMultNumber));
			}
			if (nSymbol > 0) {
				nScore = parseInt(nScore + (nSymbol * nMultSymbol));
			}
			if (nMidChar > 0) {
				nScore = parseInt(nScore + (nMidChar * nMultMidChar));
			}

			/* Point deductions for poor practices */
			if ((nAlphaLC > 0 || nAlphaUC > 0) && nSymbol === 0 && nNumber === 0) {  // Only Letters
				nScore = parseInt(nScore - nLength);
				nAlphasOnly = nLength;
			}
			if (nAlphaLC === 0 && nAlphaUC === 0 && nSymbol === 0 && nNumber > 0) {  // Only Numbers
				nScore = parseInt(nScore - nLength);
				nNumbersOnly = nLength;
			}
			if (nRepChar > 0) {  // Same character exists more than once
				nScore = parseInt(nScore - nRepInc);
			}
			if (nConsecAlphaUC > 0) {  // Consecutive Uppercase Letters exist
				nScore = parseInt(nScore - (nConsecAlphaUC * nMultConsecAlphaUC));
			}
			if (nConsecAlphaLC > 0) {  // Consecutive Lowercase Letters exist
				nScore = parseInt(nScore - (nConsecAlphaLC * nMultConsecAlphaLC));
			}
			if (nConsecNumber > 0) {  // Consecutive Numbers exist
				nScore = parseInt(nScore - (nConsecNumber * nMultConsecNumber));
			}
			if (nSeqAlpha > 0) {  // Sequential alpha strings exist (3 characters or more)
				nScore = parseInt(nScore - (nSeqAlpha * nMultSeqAlpha));
			}
			if (nSeqNumber > 0) {  // Sequential numeric strings exist (3 characters or more)
				nScore = parseInt(nScore - (nSeqNumber * nMultSeqNumber));
			}
			if (nSeqSymbol > 0) {  // Sequential symbol strings exist (3 characters or more)
				nScore = parseInt(nScore - (nSeqSymbol * nMultSeqSymbol));
			}

			/* Determine if mandatory requirements have been met and set image indicators accordingly */
			arrChars = [nLength,nAlphaUC,nAlphaLC,nNumber,nSymbol];
			arrCharsIds = ["nLength","nAlphaUC","nAlphaLC","nNumber","nSymbol"];
			arrCharsLen = arrChars.length;
			for (c=0; c < arrCharsLen; c++) {
				if (arrCharsIds[c] === "nLength") {
					minVal = parseInt(nMinPwdLen - 1);
				} else {
					minVal = 0;
				}
				if(arrChars[c] >= parseInt(minVal + 1)) {
					nReqChar++;
				}
			}
			nRequirements = nReqChar;
			if (sPassword.length >= nMinPwdLen) {
				var nMinReqChars = 3;
			} else {
				var nMinReqChars = 4;
			}
			if (nRequirements > nMinReqChars) {  // One or more required characters exist
				nScore = parseInt(nScore + (nRequirements * 2));
			}



			/*  Update the requirement icons */
			passReqMax.el.dom.src = (sPassword.length <= nMaxPwdLen? passAccept : passDecline);
			passReqMin.el.dom.src = (sPassword.length >= nMinPwdLen? passAccept : passDecline);
			passReqUpper.el.dom.src = (nAlphaUC > 0? passAccept : passDecline);
			passReqLower.el.dom.src = (nAlphaLC > 0? passAccept : passDecline);
			passReqNum.el.dom.src = (nNumber > 0? passAccept : passDecline);
			passReqSym.el.dom.src = (nSymbol > 0 || nMidChar > 0? passAccept : passDecline);



			/* Determine if additional bonuses need to be applied and set image indicators accordingly */
			arrChars = [nMidChar,nRequirements];
			arrCharsIds = ["nMidChar","nRequirements"];
			arrCharsLen = arrChars.length;
			for (c=0; c < arrCharsLen; c++) {
				if (arrCharsIds[c] == "nRequirements") {
					minVal = nMinReqChars;
				} else {
					minVal = 0;
				}
			}
			//nScore += minVal;

			/* Finalize bonuses based on set algorythms: Length, Numbers, and symbols are favored */
			nRequirements = (sPassword.length >= nMinPwdLen) * 20;
			nRequirements += (nAlphaUC > 0) * 20;
			nRequirements += (nAlphaLC > 0) * 20;
			nRequirements += (nSymbol > 0) * 20;
			nRequirements += (nUnqChar > 0) * 20;
			nLength *= 4;
			nAlphaUC = (sPassword.length - nAlphaUC) * 2;
			nAlphaLC = (sPassword.length - nAlphaLC) * 2;
			nNumber *= 3;
			nSymbol *= 8;
			nUnqChar *= 4;
			//set the max values for display in graph (-60..100)
			nRequirements = Math.min(100, nRequirements);
			nLength  = Math.min(100, nLength);
			nAlphaUC = Math.min(100, nAlphaUC);
			nAlphaLC = Math.min(100, nAlphaLC);
			nNumber = Math.min(100, nNumber);
			nSymbol = Math.min(100, nSymbol);
			nUnqChar = Math.min(100, nUnqChar);

			/* Finalize deductions based on set algorythms: bad practices are pentalized the most */
			nAlphasOnly *= -4;
			nNumbersOnly *= -1;
			nRepChar *= -1;
			nConsecNumber *= -2;
			nConsecSymbol *= -2;
			nSeqAlpha *= -3;
			nSeqNumber *= -3;
			nSeqSymbol *= -3;
			//set the min values for display in graph (-60..100)
			nAlphasOnly = Math.max(-60, nAlphasOnly);
			nNumbersOnly = Math.max(-60, nNumbersOnly);
			nRepChar = Math.max(-60, nRepChar);
			nConsecNumber = Math.max(-60, nConsecNumber);
			nConsecSymbol = Math.max(-60, nConsecSymbol);
			nSeqAlpha = Math.max(-60, nSeqAlpha);
			nSeqNumber = Math.max(-60, nSeqNumber);
			nSeqSymbol = Math.max(-60, nSeqSymbol);

			/* Display updated score criteria */
			scoreBarPos = parseInt(nScore);
			scoreBarPos = Math.min( Math.max(0, scoreBarPos*10), 800 ); // 0 <= scoreBarPos >= 800 (field is 200px wide... so we compensate.)
			scoreBar.el.dom.style.backgroundPosition = " -" + (scoreBarPos) + "px center";
		}//end if no password

		nScore = Math.min( Math.max(0, nScore), 100 ); // 0 <= nScore >= 100:
		scoreText.el.dom.innerHTML = nScore + "%";

		if (this.showChart) {

			passChartStore.loadData([
				{crypto:"Requirements",		bonus: nRequirements, deduction: 0},
				{crypto:"Length",			bonus: nLength, deduction: 0}
			]);

			// display only non-zero values
			if(nAlphaUC > 0) passChartStore.add({ crypto:"Uppercase",		bonus: nAlphaUC, deduction: 0});
			if(nAlphaLC > 0) passChartStore.add({ crypto:"Lowercase",		bonus: nAlphaLC, deduction: 0});
			if(nNumber > 0) passChartStore.add({ crypto:"Number",			bonus: nNumber, deduction: 0});
			if(nSymbol > 0) passChartStore.add({ crypto:"Symbols",			bonus: nSymbol, deduction: 0});
			if(nUnqChar > 0) passChartStore.add({ crypto:"Unique",			bonus: nUnqChar, deduction: 0});
			if(nAlphasOnly !== 0) passChartStore.add({ crypto:"Letters only",		bonus: nAlphasOnly, deduction: 1});
			if(nNumbersOnly !== 0) passChartStore.add({ crypto:"Numbers only",		bonus: nNumbersOnly, deduction: 1});
			if(nRepChar !== 0) passChartStore.add({ crypto:"Repeat Letters",			bonus: nRepChar, deduction: 1});
			if(nConsecNumber !== 0) passChartStore.add({ crypto:"Consec Numbers",	bonus: nConsecNumber, deduction: 1});
			if(nConsecSymbol !== 0) passChartStore.add({ crypto:"Consec Symbols",	bonus: nConsecSymbol, deduction: 1});
			if(nSeqAlpha !== 0) passChartStore.add({ crypto:"Seq. Letters",		bonus: nSeqAlpha, deduction: 1});
			if(nSeqNumber !== 0) passChartStore.add({ crypto:"Seq. Numbers",		bonus: nSeqNumber, deduction: 1});
			if(nSeqSymbol !== 0) passChartStore.add({ crypto:"Seq. Symbols",		bonus: nSeqSymbol, deduction: 1});
		}


	}

});
