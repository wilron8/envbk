/*
 * File: envitz/view/GridPicker.js
 *
 * This file was generated by Sencha Architect version 3.0.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.2.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('envitz.view.GridPicker', {
	extend: 'Ext.form.field.ComboBox',
	alias: 'widget.gridpicker',

	requires: [
		'Ext.grid.Panel',
		'envitz.view.GridPickerKeyNav'
	],

	initComponent: function() {
		var me = this;

		Ext.applyIf(me, {
			defaultGridConfig: {
				xclass: 'Ext.grid.Panel',
				floating: true,
				focusOnToFront: false,
				resizable: true,
				hideHeaders: true,
				stripeRows: false,
				// viewConfig: {
				// stripeRows: false
				// },
				rowLines: false,
				initComponent: function() {
					Ext.grid.Panel.prototype.initComponent.apply(this, arguments);
					
					var store = this.getStore();
					
					this.query('pagingtoolbar').forEach(function(pagingToolbar) {
						pagingToolbar.bindStore(store);
					});
				}
			},
			gridConfig: null
		});

		me.processGridPicker(me);
		me.callParent(arguments);
	},

	processGridPicker: function(config) {
		// SEE: https://github.com/rixo/GridPicker/blob/master/ux/Rixo/form/field/GridPicker.js

		if (Ext.getVersion().isLessThan('4.2.1')) {
			Ext.require('envitz.view.GridPicker-4-2-0');
		}


		// ??? more Ugliness. Why not use Ext.forEach()?

		// Polyfill for forEach
		// source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
		if (!Array.prototype.forEach) {
			Array.prototype.forEach = function(fun /*, thisArg */) {
				"use strict";

				if (this === void 0 || this === null)
					throw new TypeError();

				var t = Object(this);
				var len = t.length >>> 0;
				if (typeof fun !== "function")
					throw new TypeError();

				var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
				for (var i = 0; i < len; i++) {
					if (i in t)
						fun.call(thisArg, t[i], i, t);
				}
			};
		}
	},

	createPicker: function() {
		/**
		* Overriden: delegates to {@link #createGrid}.
		*
		* @protected
		*/


		//COPIED FROM https://github.com/rixo/GridPicker/blob/master/ux/Rixo/form/field/GridPicker.js

		// We must assign it for Combo's onAdded method to work
		return this.picker = this.createGrid();
	},

	createGrid: function() {
		/**
		* Creates the picker's grid.
		*
		* @protected
		*/

		var grid = Ext.create(this.getGridConfig());

		this.bindGrid(grid);
		return grid;
	},

	getGrid: function() {
		return this.getPicker();
	},

	getGridConfig: function() {
		/**
		* Gets the configuration for the picked's grid.
		*
		* The returned object will be modified, so it must be an instance dedicated to
		* this object.
		*
		* @return {Object}
		* @protected
		*/

		var config = {};

		Ext.apply(config, this.gridConfig, this.defaultGridConfig);

		Ext.applyIf(config, {
			store: this.store,

			columns: [{
				dataIndex: this.displayField || this.valueField,
				flex: 1
			}]
		});

		// Avoid "Layout run failed" error
		// See: http://stackoverflow.com/a/21740832/1387519
		if (!config.width) {
			config.width = this.inputEl.getWidth();
		}

		return config;
	},

	bindGrid: function(grid) {
		/**
		* Binds the specified grid to this picker.
		*
		* @param {Ext.grid.Panel}
		* @private
		*/
		this.grid = grid;

		grid.ownerCt = this;
		grid.registerWithOwnerCt();

		this.mon(grid, {
			scope: this,

			itemclick: this.onItemClick,
			refresh: this.onListRefresh,

			beforeselect: this.onBeforeSelect,
			beforedeselect: this.onBeforeDeselect,
			selectionchange: this.onListSelectionChange,

			// fix the fucking buffered view!!!
			afterlayout: function(grid) {
				if (grid.getStore().getCount()) { //TODO: rename ~~grid.fixingTheFuckingLayout~~ config
					if (!grid.fixingTheFuckingLayout) {
						var el = grid.getView().el;
						grid.fixingTheFuckingLayout = true;
						el.setHeight('100%');
						el.setStyle('overflow-x', 'hidden');
						grid.fixingTheFuckingLayout = false;
					}
				}
			}

		});

		// Prevent deselectAll, that is called liberally in combo box code, to actually deselect
		// the current value
		var me = this,
			sm = grid.getSelectionModel(),
			uber = sm.deselectAll;
		sm.deselectAll = function() {
			if (!me.ignoreSelection) {
				uber.apply(this, arguments);
			}
		};
	},

	highlightRecord: function(record) {
		/**
		* Highlight (i.e. select) the specified record.
		*
		* @param {Ext.data.Record}
		* @private
		*/

		var grid = this.getGrid(),
			sm = grid.getSelectionModel(),
			view = grid.getView(),
			node = view.getNode(record),
			plugins = grid.plugins,
			bufferedPlugin = plugins && plugins.filter(function(p) {
				return p instanceof Ext.grid.plugin.BufferedRenderer;
			})[0];

		sm.select(record, false, true);

		if (node) {
			Ext.fly(node).scrollIntoView(view.el, false);
		} else if (bufferedPlugin) {
			bufferedPlugin.scrollTo(grid.store.indexOf(record));
		}
	},

	highlightAt: function(index) {
		/**
		* Highlight the record at the specified index.
		*
		* @param {Integer} index
		* @private
		*/

		var grid = this.getGrid(),
			sm = grid.getSelectionModel(),
			view = grid.getView(),
			node = view.getNode(index),
			plugins = grid.plugins,
			bufferedPlugin = plugins && plugins.filter(function(p) {
				return p instanceof Ext.grid.plugin.BufferedRenderer;
			})[0];

		sm.select(index, false, true);

		if (node) {
			Ext.fly(node).scrollIntoView(view.el, false);
		} else if (bufferedPlugin) {
			bufferedPlugin.scrollTo(index);
		}
	},

	onExpand: function() {
		// private
		var me = this,
			keyNav = me.listKeyNav,
			selectOnTab = me.selectOnTab;

		// Handle BoundList navigation from the input field. Insert a tab listener specially to enable selectOnTab.
		if (keyNav) {
			keyNav.enable();
		} else {
			keyNav = me.listKeyNav = Ext.create('Ext.ux.Rixo.form.field.GridPickerKeyNav', {
				target: this.inputEl,
				forceKeyDown: true,
				pickerField: this,
				grid: this.getGrid()
			});
		}

		// While list is expanded, stop tab monitoring from Ext.form.field.Trigger so it doesn't short-circuit selectOnTab
		if (selectOnTab) {
			me.ignoreMonitorTab = true;
		}

		Ext.defer(keyNav.enable, 1, keyNav); //wait a bit so it doesn't react to the down arrow opening the picker

		this.focusWithoutSelection(10);
	},

	focusWithoutSelection: function(delay) {
		// private

		/// ??? very ugly!

		function focus() {
			var me = this,
				previous = me.selectOnFocus;
			me.selectOnFocus = false;
			me.inputEl.focus();
			me.selectOnFocus = previous;
		}

		return function(delay) {
			if (Ext.isNumber(delay)) {
				// Ext.defer(focus, delay, me.inputEl);
				Ext.defer(focus, delay, this);
			} else {
				focus.call(this);
			}
		};
	},

	doAutoSelect: function() {
		// private

		var me = this,
			picker = me.picker,
			lastSelected, itemNode;

		if (picker && me.autoSelect && me.store.getCount() > 0) {
			// Highlight the last selected item and scroll it into view
			lastSelected = picker.getSelectionModel().lastSelected;
			if (lastSelected) {
				picker.getSelectionModel().select(lastSelected, false, true);
			}
		}
	},

	onTypeAhead: function() {
		// private

		var me = this,
			displayField = me.displayField,
			record = me.store.findRecord(displayField, me.getRawValue()),
			grid = me.getPicker(),
			newValue, len, selStart;

		if (record) {
			newValue = record.get(displayField);
			len = newValue.length;
			selStart = me.getRawValue().length;

			//grid.highlightItem(grid.getNode(record));
			this.highlightRecord(record);

			if (selStart !== 0 && selStart !== len) {
				me.setRawValue(newValue);
				me.selectText(selStart, newValue.length);
			}
		}
	}

});