/*
 * File: envitz/view/ComboGrid.js
 *
 * This file was generated by Sencha Architect version 3.0.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.2.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('envitz.view.ComboGrid', {
	extend: 'Ext.form.field.ComboBox',
	alias: 'widget.combogrid',

	requires: [
		'Ext.grid.Panel'
	],

	fieldLabel: 'Label',
	hideLabel: true,

	initComponent: function() {
		var me = this;

		me.callParent(arguments);
	},

	createPicker: function() {
		//COPIED FROM SENCHA FORUM: http://www.sencha.com/forum/showthread.php?132328-CLOSED-ComboBox-using-Grid-instead-of-BoundList

		// copied from ComboBox
		var me = this,
			picker,
			menuCls = Ext.baseCSSPrefix + 'menu',
			opts = Ext.apply({
				selModel: {
					mode: me.multiSelect ? 'SIMPLE' : 'SINGLE'
				},
				floating: true,
				hidden: true,
				ownerCt: me.ownerCt,
				cls: me.el.up('.' + menuCls) ? menuCls : '',
				store: me.store,
				displayField: me.displayField,
				focusOnToFront: false,
				pageSize: me.pageSize
			}, me.listConfig, me.defaultListConfig);


		// NOTE: we simply use a grid panel
		//picker = me.picker = Ext.create('Ext.view.BoundList', opts);


		picker = me.picker = Ext.create('Ext.grid.Panel', opts);


		// hack: pass getNode() to the view
		picker.getNode = function() {
			picker.getView().getNode.apply(picker.getView(), arguments);
		};


		me.mon(picker.getView(), {
			refresh: me.onListRefresh,
			scope:me
		});
		me.mon(picker, {
			itemclick: me.onItemClick,
			//            refresh: me.onListRefresh,
			scope: me
		});


		me.mon(picker.getSelectionModel(), {
			selectionChange: me.onListSelectionChange,
			scope: me
		});


		return picker;
		}
	},

	onExpand: function() {
		var me = this,
			keyNav = me.listKeyNav,
			selectOnTab = me.selectOnTab,
			picker = me.getPicker();


		// Handle BoundList navigation from the input field. Insert a tab listener specially to enable selectOnTab.
		keyNav = me.listKeyNav = keyNav = new Ext.util.KeyNav(this.inputEl, {
			scope: picker,
			up: function() {
				if(this.coursorPosition == null || this.coursorPosition == 0){
					this.coursorPosition = this.getStore().count()-1;
				}
				this.coursorPosition = this.coursorPosition-1;
				var selModel = this.getSelectionModel();
				selModel.select(this.coursorPosition);
				this.getView().getNode(this.coursorPosition).scrollIntoView();
			},
			down: function() {
				if(this.coursorPosition == null || this.coursorPosition == this.getStore().count()-1){
					this.coursorPosition = 0;
				}
				this.coursorPosition = this.coursorPosition+1;
				var selModel = this.getSelectionModel();
				selModel.select(this.coursorPosition);
				this.getView().getNode(this.coursorPosition).scrollIntoView();
			}
		});


		// While list is expanded, stop tab monitoring from Ext.form.field.Trigger so it doesn't short-circuit selectOnTab
		if (selectOnTab) {
			me.ignoreMonitorTab = true;
		}


		Ext.defer(keyNav.enable, 1, keyNav); //wait a bit so it doesn't react to the down arrow opening the picker
		me.inputEl.focus();


		if (keyNav || !me.filterPickList) {
			return;
		}
		keyNav = me.listKeyNav;
		keyNav.highlightAt = function(index) {
			var boundList = this.boundList,
				item = boundList.all.item(index),
				len = boundList.all.getCount(),
				direction;


			if (item && item.hasCls('x-boundlist-selected')) {
				if ((index == 0) || !boundList.highlightedItem || (boundList.indexOf(boundList.highlightedItem) < index)) {
					direction = 1;
				} else {
					direction = -1;
				}
				do {
					index = index + direction;
					item = boundList.all.item(index);
				} while ((index > 0) && (index < len) && item.hasCls('x-boundlist-selected'));


				if (item.hasCls('x-boundlist-selected')) {
					return;
				}
			}


			if (item) {
				item = item.dom;
				boundList.highlightItem(item);
				boundList.getTargetEl().scrollChildIntoView(item, false);
			}
		};
	}

});